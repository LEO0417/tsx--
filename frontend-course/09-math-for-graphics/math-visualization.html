<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å›¾å½¢æ•°å­¦å¯è§†åŒ– - ç¬¬9è¯¾å®è·µé¡¹ç›®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            background: linear-gradient(135deg, #0c1445 0%, #1e3c72 50%, #2a5298 100%);
            min-height: 100vh;
            padding: 20px;
            color: white;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 20px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .header h1 {
            font-size: 42px;
            margin-bottom: 15px;
            background: linear-gradient(45deg, #ff6b6b, #4ecdc4, #45b7d1, #f9ca24, #e17055);
            background-size: 400% 400%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientFlow 4s ease-in-out infinite;
        }

        @keyframes gradientFlow {
            0%, 100% { background-position: 0% 50%; }
            25% { background-position: 100% 50%; }
            50% { background-position: 50% 100%; }
            75% { background-position: 50% 0%; }
        }

        .demo-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(450px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .demo-card {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 25px;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            transition: all 0.4s ease;
            position: relative;
            overflow: hidden;
        }

        .demo-card::before {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(45deg, transparent, rgba(255, 255, 255, 0.03), transparent);
            transform: rotate(45deg);
            transition: transform 0.6s ease;
        }

        .demo-card:hover::before {
            transform: rotate(45deg) translate(50%, 50%);
        }

        .demo-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.3);
        }

        .demo-title {
            font-size: 22px;
            margin-bottom: 20px;
            color: #4ecdc4;
            text-align: center;
            font-weight: 600;
            position: relative;
            z-index: 1;
        }

        .demo-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 15px;
            padding: 20px;
            min-height: 350px;
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 12px;
            flex-wrap: wrap;
            position: relative;
            z-index: 1;
        }

        .btn {
            padding: 10px 18px;
            border: none;
            border-radius: 10px;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            color: white;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.3);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            background: linear-gradient(135deg, #26a085, #3d8b7c);
            transform: translateY(-3px);
            box-shadow: 0 6px 20px rgba(78, 205, 196, 0.4);
        }

        .btn.active {
            background: linear-gradient(135deg, #ff6b6b, #ee5a52);
            box-shadow: 0 4px 15px rgba(255, 107, 107, 0.4);
        }

        .slider-container {
            display: flex;
            align-items: center;
            gap: 15px;
            margin: 15px 0;
            background: rgba(255, 255, 255, 0.05);
            padding: 12px 20px;
            border-radius: 12px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .slider-label {
            font-size: 14px;
            font-weight: 500;
            min-width: 80px;
            color: #b8e6d1;
        }

        input[type="range"] {
            flex: 1;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.2);
            outline: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4ecdc4, #44a08d);
            cursor: pointer;
            border: 3px solid white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 15px rgba(78, 205, 196, 0.5);
        }

        .value-display {
            font-size: 14px;
            color: #4ecdc4;
            font-weight: 600;
            min-width: 50px;
            text-align: center;
            background: rgba(78, 205, 196, 0.1);
            padding: 5px 10px;
            border-radius: 8px;
        }

        canvas {
            border-radius: 12px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.8), rgba(0, 0, 0, 0.6));
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-top: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .info-panel h4 {
            color: #4ecdc4;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .info-panel p {
            font-size: 13px;
            line-height: 1.5;
            color: rgba(255, 255, 255, 0.8);
        }

        .formula {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px 15px;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 14px;
            color: #f9ca24;
            border-left: 4px solid #4ecdc4;
            margin: 10px 0;
        }

        /* ç‰¹æ®Šæ•ˆæœ */
        .glow {
            box-shadow: 0 0 20px rgba(78, 205, 196, 0.3);
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 768px) {
            .demo-grid {
                grid-template-columns: 1fr;
            }
            
            .header h1 {
                font-size: 32px;
            }
            
            .demo-card {
                padding: 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ“ å›¾å½¢æ•°å­¦å¯è§†åŒ–</h1>
            <p>æ¢ç´¢å‘é‡ã€çŸ©é˜µã€ä¸‰è§’å‡½æ•°ã€è´å¡å°”æ›²çº¿ç­‰æ•°å­¦æ¦‚å¿µåœ¨å›¾å½¢ç¼–ç¨‹ä¸­çš„åº”ç”¨</p>
        </div>

        <div class="demo-grid">
            <!-- å‘é‡æ¼”ç¤º -->
            <div class="demo-card">
                <h3 class="demo-title">ğŸ“ å‘é‡æ“ä½œ</h3>
                <div class="demo-area">
                    <canvas id="vectorCanvas" width="400" height="300"></canvas>
                </div>
                <div class="slider-container">
                    <span class="slider-label">å‘é‡Aè§’åº¦:</span>
                    <input type="range" id="vectorAAngle" min="0" max="360" value="45">
                    <span class="value-display" id="vectorAAngleValue">45Â°</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">å‘é‡Bè§’åº¦:</span>
                    <input type="range" id="vectorBAngle" min="0" max="360" value="135">
                    <span class="value-display" id="vectorBAngleValue">135Â°</span>
                </div>
                <div class="controls">
                    <button class="btn" onclick="showVectorOperation('add')">å‘é‡ç›¸åŠ </button>
                    <button class="btn" onclick="showVectorOperation('subtract')">å‘é‡ç›¸å‡</button>
                    <button class="btn" onclick="showVectorOperation('dot')">ç‚¹ç§¯</button>
                    <button class="btn" onclick="showVectorOperation('cross')">å‰ç§¯</button>
                </div>
                <div class="info-panel">
                    <h4>å½“å‰æ“ä½œï¼š<span id="vectorOperation">å‘é‡ç›¸åŠ </span></h4>
                    <p id="vectorResult">ç»“æœå°†åœ¨è¿™é‡Œæ˜¾ç¤º</p>
                    <div class="formula" id="vectorFormula">a + b = (ax + bx, ay + by)</div>
                </div>
            </div>

            <!-- ä¸‰è§’å‡½æ•°æ¼”ç¤º -->
            <div class="demo-card">
                <h3 class="demo-title">ğŸ“Š ä¸‰è§’å‡½æ•°æ³¢å½¢</h3>
                <div class="demo-area">
                    <canvas id="trigCanvas" width="400" height="300"></canvas>
                </div>
                <div class="slider-container">
                    <span class="slider-label">é¢‘ç‡:</span>
                    <input type="range" id="frequency" min="0.1" max="5" step="0.1" value="1">
                    <span class="value-display" id="frequencyValue">1.0</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">æŒ¯å¹…:</span>
                    <input type="range" id="amplitude" min="10" max="100" value="50">
                    <span class="value-display" id="amplitudeValue">50</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">ç›¸ä½:</span>
                    <input type="range" id="phase" min="0" max="360" value="0">
                    <span class="value-display" id="phaseValue">0Â°</span>
                </div>
                <div class="controls">
                    <button class="btn active" onclick="selectTrigFunction('sin')">æ­£å¼¦</button>
                    <button class="btn" onclick="selectTrigFunction('cos')">ä½™å¼¦</button>
                    <button class="btn" onclick="selectTrigFunction('tan')">æ­£åˆ‡</button>
                    <button class="btn" onclick="selectTrigFunction('combined')">ç»„åˆ</button>
                </div>
                <div class="info-panel">
                    <h4>ä¸‰è§’å‡½æ•°æ€§è´¨</h4>
                    <p>è°ƒæ•´å‚æ•°è§‚å¯Ÿæ³¢å½¢å˜åŒ–ï¼šé¢‘ç‡å½±å“å‘¨æœŸï¼ŒæŒ¯å¹…å½±å“é«˜åº¦ï¼Œç›¸ä½å½±å“èµ·å§‹ä½ç½®</p>
                    <div class="formula" id="trigFormula">y = A Ã— sin(f Ã— x + Ï†)</div>
                </div>
            </div>

            <!-- çŸ©é˜µå˜æ¢æ¼”ç¤º -->
            <div class="demo-card">
                <h3 class="demo-title">ğŸ”„ çŸ©é˜µå˜æ¢</h3>
                <div class="demo-area">
                    <canvas id="matrixCanvas" width="400" height="300"></canvas>
                </div>
                <div class="slider-container">
                    <span class="slider-label">æ—‹è½¬è§’åº¦:</span>
                    <input type="range" id="rotation" min="0" max="360" value="0">
                    <span class="value-display" id="rotationValue">0Â°</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">ç¼©æ”¾X:</span>
                    <input type="range" id="scaleX" min="0.1" max="3" step="0.1" value="1">
                    <span class="value-display" id="scaleXValue">1.0</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">ç¼©æ”¾Y:</span>
                    <input type="range" id="scaleY" min="0.1" max="3" step="0.1" value="1">
                    <span class="value-display" id="scaleYValue">1.0</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">å€¾æ–œX:</span>
                    <input type="range" id="skewX" min="-1" max="1" step="0.1" value="0">
                    <span class="value-display" id="skewXValue">0.0</span>
                </div>
                <div class="controls">
                    <button class="btn" onclick="resetMatrix()">é‡ç½®</button>
                    <button class="btn" onclick="animateMatrix()">åŠ¨ç”»æ¼”ç¤º</button>
                    <button class="btn" onclick="showMatrixInfo()">çŸ©é˜µä¿¡æ¯</button>
                </div>
                <div class="info-panel">
                    <h4>å˜æ¢çŸ©é˜µ</h4>
                    <p>è§‚å¯Ÿä¸åŒå˜æ¢å‚æ•°å¯¹å›¾å½¢çš„å½±å“</p>
                    <div class="formula" id="matrixFormula">
                        [x'] = [a c tx] [x]<br>
                        [y'] = [b d ty] [y]<br>
                        [1 ] = [0 0 1 ] [1]
                    </div>
                </div>
            </div>

            <!-- è´å¡å°”æ›²çº¿æ¼”ç¤º -->
            <div class="demo-card">
                <h3 class="demo-title">ğŸ¨ è´å¡å°”æ›²çº¿</h3>
                <div class="demo-area">
                    <canvas id="bezierCanvas" width="400" height="300"></canvas>
                </div>
                <div class="slider-container">
                    <span class="slider-label">æ§åˆ¶ç‚¹1 X:</span>
                    <input type="range" id="cp1x" min="0" max="400" value="100">
                    <span class="value-display" id="cp1xValue">100</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">æ§åˆ¶ç‚¹1 Y:</span>
                    <input type="range" id="cp1y" min="0" max="300" value="50">
                    <span class="value-display" id="cp1yValue">50</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">æ§åˆ¶ç‚¹2 X:</span>
                    <input type="range" id="cp2x" min="0" max="400" value="300">
                    <span class="value-display" id="cp2xValue">300</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">æ§åˆ¶ç‚¹2 Y:</span>
                    <input type="range" id="cp2y" min="0" max="300" value="250">
                    <span class="value-display" id="cp2yValue">250</span>
                </div>
                <div class="controls">
                    <button class="btn" onclick="setBezierType('quadratic')">äºŒæ¬¡æ›²çº¿</button>
                    <button class="btn active" onclick="setBezierType('cubic')">ä¸‰æ¬¡æ›²çº¿</button>
                    <button class="btn" onclick="animateBezier()">åŠ¨ç”»æ¼”ç¤º</button>
                    <button class="btn" onclick="showBezierConstruction()">æ„é€ è¿‡ç¨‹</button>
                </div>
                <div class="info-panel">
                    <h4>è´å¡å°”æ›²çº¿</h4>
                    <p>è°ƒæ•´æ§åˆ¶ç‚¹è§‚å¯Ÿæ›²çº¿å½¢çŠ¶å˜åŒ–ï¼Œäº†è§£è´å¡å°”æ›²çº¿çš„æ„é€ åŸç†</p>
                    <div class="formula" id="bezierFormula">B(t) = (1-t)Â³Pâ‚€ + 3(1-t)Â²tPâ‚ + 3(1-t)tÂ²Pâ‚‚ + tÂ³Pâ‚ƒ</div>
                </div>
            </div>

            <!-- æåæ ‡æ¼”ç¤º -->
            <div class="demo-card">
                <h3 class="demo-title">ğŸŒ€ æåæ ‡å›¾å½¢</h3>
                <div class="demo-area">
                    <canvas id="polarCanvas" width="400" height="300"></canvas>
                </div>
                <div class="slider-container">
                    <span class="slider-label">å‚æ•°A:</span>
                    <input type="range" id="polarA" min="1" max="10" value="3">
                    <span class="value-display" id="polarAValue">3</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">å‚æ•°B:</span>
                    <input type="range" id="polarB" min="1" max="10" value="2">
                    <span class="value-display" id="polarBValue">2</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">ç¼©æ”¾:</span>
                    <input type="range" id="polarScale" min="0.1" max="3" step="0.1" value="1">
                    <span class="value-display" id="polarScaleValue">1.0</span>
                </div>
                <div class="controls">
                    <button class="btn active" onclick="setPolarType('rose')">ç«ç‘°çº¿</button>
                    <button class="btn" onclick="setPolarType('spiral')">èºæ—‹çº¿</button>
                    <button class="btn" onclick="setPolarType('cardioid')">å¿ƒå½¢çº¿</button>
                    <button class="btn" onclick="setPolarType('lemniscate')">åŒçº½çº¿</button>
                </div>
                <div class="info-panel">
                    <h4>æåæ ‡æ–¹ç¨‹</h4>
                    <p>æ¢ç´¢å„ç§æåæ ‡å›¾å½¢çš„æ•°å­¦ç¾</p>
                    <div class="formula" id="polarFormula">r = a Ã— sin(b Ã— Î¸)</div>
                </div>
            </div>

            <!-- å™ªå£°å‡½æ•°æ¼”ç¤º -->
            <div class="demo-card">
                <h3 class="demo-title">ğŸŒŠ å™ªå£°å‡½æ•°</h3>
                <div class="demo-area">
                    <canvas id="noiseCanvas" width="400" height="300"></canvas>
                </div>
                <div class="slider-container">
                    <span class="slider-label">é¢‘ç‡:</span>
                    <input type="range" id="noiseFreq" min="0.01" max="0.1" step="0.01" value="0.05">
                    <span class="value-display" id="noiseFreqValue">0.05</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">æŒ¯å¹…:</span>
                    <input type="range" id="noiseAmp" min="10" max="100" value="50">
                    <span class="value-display" id="noiseAmpValue">50</span>
                </div>
                <div class="slider-container">
                    <span class="slider-label">å…«åº¦:</span>
                    <input type="range" id="noiseOctaves" min="1" max="8" value="4">
                    <span class="value-display" id="noiseOctavesValue">4</span>
                </div>
                <div class="controls">
                    <button class="btn active" onclick="setNoiseType('perlin')">Perlinå™ªå£°</button>
                    <button class="btn" onclick="setNoiseType('simplex')">Simplexå™ªå£°</button>
                    <button class="btn" onclick="setNoiseType('fractal')">åˆ†å½¢å™ªå£°</button>
                    <button class="btn" onclick="animateNoise()">åŠ¨ç”»</button>
                </div>
                <div class="info-panel">
                    <h4>å™ªå£°å‡½æ•°åº”ç”¨</h4>
                    <p>å™ªå£°å‡½æ•°åœ¨åœ°å½¢ç”Ÿæˆã€çº¹ç†åˆ›å»ºã€åŠ¨ç”»æ•ˆæœä¸­çš„é‡è¦ä½œç”¨</p>
                    <div class="formula" id="noiseFormula">noise(x, y, t) = Î£(amplitude Ã— noise(frequency Ã— x, frequency Ã— y, t))</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // æ•°å­¦å¯è§†åŒ–æ§åˆ¶å™¨
        class MathVisualization {
            constructor() {
                this.setupCanvases();
                this.setupEventListeners();
                this.setupAnimations();
                this.initializeVisualizations();
            }

            setupCanvases() {
                this.canvases = {
                    vector: { canvas: document.getElementById('vectorCanvas'), ctx: null },
                    trig: { canvas: document.getElementById('trigCanvas'), ctx: null },
                    matrix: { canvas: document.getElementById('matrixCanvas'), ctx: null },
                    bezier: { canvas: document.getElementById('bezierCanvas'), ctx: null },
                    polar: { canvas: document.getElementById('polarCanvas'), ctx: null },
                    noise: { canvas: document.getElementById('noiseCanvas'), ctx: null }
                };

                Object.values(this.canvases).forEach(canvasObj => {
                    canvasObj.ctx = canvasObj.canvas.getContext('2d');
                    canvasObj.ctx.imageSmoothingEnabled = true;
                });

                // è®¾ç½®é«˜DPIæ”¯æŒ
                Object.values(this.canvases).forEach(canvasObj => {
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvasObj.canvas.getBoundingClientRect();
                    canvasObj.canvas.width = rect.width * dpr;
                    canvasObj.canvas.height = rect.height * dpr;
                    canvasObj.ctx.scale(dpr, dpr);
                    canvasObj.canvas.style.width = rect.width + 'px';
                    canvasObj.canvas.style.height = rect.height + 'px';
                });
            }

            setupEventListeners() {
                // æ»‘å—äº‹ä»¶ç›‘å¬
                const sliders = [
                    'vectorAAngle', 'vectorBAngle', 'frequency', 'amplitude', 'phase',
                    'rotation', 'scaleX', 'scaleY', 'skewX', 'cp1x', 'cp1y', 'cp2x', 'cp2y',
                    'polarA', 'polarB', 'polarScale', 'noiseFreq', 'noiseAmp', 'noiseOctaves'
                ];

                sliders.forEach(sliderId => {
                    const slider = document.getElementById(sliderId);
                    const valueDisplay = document.getElementById(sliderId + 'Value');
                    
                    if (slider && valueDisplay) {
                        slider.addEventListener('input', (e) => {
                            let value = parseFloat(e.target.value);
                            
                            // æ ¼å¼åŒ–æ˜¾ç¤ºå€¼
                            if (sliderId.includes('Angle') || sliderId === 'phase' || sliderId === 'rotation') {
                                valueDisplay.textContent = value + 'Â°';
                            } else if (sliderId.includes('freq') || sliderId.includes('Scale') || sliderId.includes('scale')) {
                                valueDisplay.textContent = value.toFixed(2);
                            } else {
                                valueDisplay.textContent = value.toString();
                            }
                            
                            this.updateVisualization(sliderId);
                        });
                    }
                });
            }

            setupAnimations() {
                this.animationStates = {
                    trigTime: 0,
                    matrixTime: 0,
                    bezierTime: 0,
                    noiseTime: 0,
                    running: {
                        matrix: false,
                        bezier: false,
                        noise: false
                    }
                };

                this.startAnimationLoop();
            }

            startAnimationLoop() {
                const animate = () => {
                    this.animationStates.trigTime += 0.02;
                    
                    if (this.animationStates.running.matrix) {
                        this.animationStates.matrixTime += 0.02;
                        this.drawMatrixTransformation();
                    }
                    
                    if (this.animationStates.running.bezier) {
                        this.animationStates.bezierTime += 0.01;
                        if (this.animationStates.bezierTime > 1) {
                            this.animationStates.bezierTime = 0;
                        }
                        this.drawBezierCurve();
                    }
                    
                    if (this.animationStates.running.noise) {
                        this.animationStates.noiseTime += 0.02;
                        this.drawNoise();
                    }
                    
                    this.drawTrigonometry();
                    requestAnimationFrame(animate);
                };
                animate();
            }

            initializeVisualizations() {
                this.currentStates = {
                    vectorOperation: 'add',
                    trigFunction: 'sin',
                    bezierType: 'cubic',
                    polarType: 'rose',
                    noiseType: 'perlin'
                };

                this.drawVectors();
                this.drawTrigonometry();
                this.drawMatrixTransformation();
                this.drawBezierCurve();
                this.drawPolarGraphs();
                this.drawNoise();
            }

            updateVisualization(sliderId) {
                if (sliderId.includes('vector')) {
                    this.drawVectors();
                } else if (['frequency', 'amplitude', 'phase'].includes(sliderId)) {
                    // ä¸‰è§’å‡½æ•°ä¼šåœ¨åŠ¨ç”»å¾ªç¯ä¸­è‡ªåŠ¨æ›´æ–°
                } else if (['rotation', 'scaleX', 'scaleY', 'skewX'].includes(sliderId)) {
                    this.drawMatrixTransformation();
                } else if (sliderId.includes('cp')) {
                    this.drawBezierCurve();
                } else if (sliderId.includes('polar')) {
                    this.drawPolarGraphs();
                } else if (sliderId.includes('noise')) {
                    this.drawNoise();
                }
            }

            // å‘é‡å¯è§†åŒ–
            drawVectors() {
                const ctx = this.canvases.vector.ctx;
                ctx.clearRect(0, 0, 400, 300);
                
                const centerX = 200;
                const centerY = 150;
                const scale = 80;
                
                // è·å–è§’åº¦
                const angleA = parseFloat(document.getElementById('vectorAAngle').value) * Math.PI / 180;
                const angleB = parseFloat(document.getElementById('vectorBAngle').value) * Math.PI / 180;
                
                // è®¡ç®—å‘é‡
                const vectorA = { x: Math.cos(angleA), y: Math.sin(angleA) };
                const vectorB = { x: Math.cos(angleB), y: Math.sin(angleB) };
                
                // ç»˜åˆ¶åæ ‡è½´
                this.drawAxes(ctx, centerX, centerY, 180);
                
                // ç»˜åˆ¶å‘é‡A (çº¢è‰²)
                this.drawVector(ctx, centerX, centerY, vectorA.x * scale, -vectorA.y * scale, '#ff6b6b', 'A');
                
                // ç»˜åˆ¶å‘é‡B (è“è‰²)
                this.drawVector(ctx, centerX, centerY, vectorB.x * scale, -vectorB.y * scale, '#4ecdc4', 'B');
                
                // æ ¹æ®å½“å‰æ“ä½œç»˜åˆ¶ç»“æœ
                this.drawVectorResult(ctx, centerX, centerY, vectorA, vectorB, scale);
            }

            drawVector(ctx, startX, startY, dx, dy, color, label) {
                const endX = startX + dx;
                const endY = startY + dy;
                
                // ç»˜åˆ¶å‘é‡çº¿
                ctx.strokeStyle = color;
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.lineTo(endX, endY);
                ctx.stroke();
                
                // ç»˜åˆ¶ç®­å¤´
                const angle = Math.atan2(dy, dx);
                const arrowLength = 15;
                const arrowAngle = Math.PI / 6;
                
                ctx.beginPath();
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle - arrowAngle),
                    endY - arrowLength * Math.sin(angle - arrowAngle)
                );
                ctx.moveTo(endX, endY);
                ctx.lineTo(
                    endX - arrowLength * Math.cos(angle + arrowAngle),
                    endY - arrowLength * Math.sin(angle + arrowAngle)
                );
                ctx.stroke();
                
                // ç»˜åˆ¶æ ‡ç­¾
                ctx.fillStyle = color;
                ctx.font = 'bold 16px Arial';
                ctx.fillText(label, endX + 10, endY - 10);
            }

            drawVectorResult(ctx, centerX, centerY, vectorA, vectorB, scale) {
                const operation = this.currentStates.vectorOperation;
                let result = { x: 0, y: 0 };
                let resultText = '';
                let formula = '';
                
                switch (operation) {
                    case 'add':
                        result = { x: vectorA.x + vectorB.x, y: vectorA.y + vectorB.y };
                        this.drawVector(ctx, centerX, centerY, result.x * scale, -result.y * scale, '#f9ca24', 'A+B');
                        resultText = `A + B = (${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
                        formula = 'a + b = (ax + bx, ay + by)';
                        break;
                    case 'subtract':
                        result = { x: vectorA.x - vectorB.x, y: vectorA.y - vectorB.y };
                        this.drawVector(ctx, centerX, centerY, result.x * scale, -result.y * scale, '#e17055', 'A-B');
                        resultText = `A - B = (${result.x.toFixed(2)}, ${result.y.toFixed(2)})`;
                        formula = 'a - b = (ax - bx, ay - by)';
                        break;
                    case 'dot':
                        const dotProduct = vectorA.x * vectorB.x + vectorA.y * vectorB.y;
                        resultText = `A Â· B = ${dotProduct.toFixed(3)}`;
                        formula = 'a Â· b = ax Ã— bx + ay Ã— by';
                        
                        // ç»˜åˆ¶è§’åº¦
                        const angle = Math.acos(dotProduct);
                        ctx.strokeStyle = '#f9ca24';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, 30, -Math.atan2(vectorA.y, vectorA.x), -Math.atan2(vectorB.y, vectorB.x));
                        ctx.stroke();
                        break;
                    case 'cross':
                        const crossProduct = vectorA.x * vectorB.y - vectorA.y * vectorB.x;
                        resultText = `A Ã— B = ${crossProduct.toFixed(3)} (æ ‡é‡)`;
                        formula = 'a Ã— b = ax Ã— by - ay Ã— bx';
                        break;
                }
                
                document.getElementById('vectorResult').textContent = resultText;
                document.getElementById('vectorFormula').textContent = formula;
            }

            drawAxes(ctx, centerX, centerY, length) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                // Xè½´
                ctx.moveTo(centerX - length, centerY);
                ctx.lineTo(centerX + length, centerY);
                // Yè½´
                ctx.moveTo(centerX, centerY - length);
                ctx.lineTo(centerX, centerY + length);
                ctx.stroke();
                
                // ç½‘æ ¼
                for (let i = -length; i <= length; i += 40) {
                    if (i !== 0) {
                        ctx.beginPath();
                        ctx.moveTo(centerX + i, centerY - 5);
                        ctx.lineTo(centerX + i, centerY + 5);
                        ctx.moveTo(centerX - 5, centerY + i);
                        ctx.lineTo(centerX + 5, centerY + i);
                        ctx.stroke();
                    }
                }
            }

            // ä¸‰è§’å‡½æ•°å¯è§†åŒ–
            drawTrigonometry() {
                const ctx = this.canvases.trig.ctx;
                ctx.clearRect(0, 0, 400, 300);
                
                const frequency = parseFloat(document.getElementById('frequency').value);
                const amplitude = parseFloat(document.getElementById('amplitude').value);
                const phase = parseFloat(document.getElementById('phase').value) * Math.PI / 180;
                const centerY = 150;
                
                // ç»˜åˆ¶åæ ‡è½´
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, centerY);
                ctx.lineTo(400, centerY);
                ctx.moveTo(20, 0);
                ctx.lineTo(20, 300);
                ctx.stroke();
                
                // ç»˜åˆ¶å‡½æ•°æ›²çº¿
                const funcType = this.currentStates.trigFunction;
                ctx.lineWidth = 3;
                
                if (funcType === 'combined') {
                    // ç»˜åˆ¶å¤šä¸ªå‡½æ•°
                    this.drawTrigFunction(ctx, 'sin', frequency, amplitude, phase, centerY, '#ff6b6b');
                    this.drawTrigFunction(ctx, 'cos', frequency, amplitude * 0.7, phase, centerY, '#4ecdc4');
                } else {
                    this.drawTrigFunction(ctx, funcType, frequency, amplitude, phase + this.animationStates.trigTime, centerY, '#4ecdc4');
                }
                
                // ç»˜åˆ¶æ ‡ç­¾
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText('0', 15, centerY + 15);
                ctx.fillText('Ï€', 100, centerY + 15);
                ctx.fillText('2Ï€', 180, centerY + 15);
            }

            drawTrigFunction(ctx, type, frequency, amplitude, phase, centerY, color) {
                ctx.strokeStyle = color;
                ctx.beginPath();
                
                for (let x = 0; x < 400; x++) {
                    const t = (x - 20) * 0.02;
                    let y;
                    
                    switch (type) {
                        case 'sin':
                            y = centerY - amplitude * Math.sin(frequency * t + phase);
                            break;
                        case 'cos':
                            y = centerY - amplitude * Math.cos(frequency * t + phase);
                            break;
                        case 'tan':
                            y = centerY - amplitude * Math.tan(frequency * t + phase) * 0.1;
                            y = Math.max(0, Math.min(300, y)); // é™åˆ¶èŒƒå›´
                            break;
                    }
                    
                    if (x === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
            }

            // çŸ©é˜µå˜æ¢å¯è§†åŒ–
            drawMatrixTransformation() {
                const ctx = this.canvases.matrix.ctx;
                ctx.clearRect(0, 0, 400, 300);
                
                const centerX = 200;
                const centerY = 150;
                
                // ç»˜åˆ¶åæ ‡è½´
                this.drawAxes(ctx, centerX, centerY, 150);
                
                // è·å–å˜æ¢å‚æ•°
                const rotation = parseFloat(document.getElementById('rotation').value) * Math.PI / 180;
                const scaleX = parseFloat(document.getElementById('scaleX').value);
                const scaleY = parseFloat(document.getElementById('scaleY').value);
                const skewX = parseFloat(document.getElementById('skewX').value);
                
                // å¦‚æœåŠ¨ç”»è¿è¡Œï¼Œä½¿ç”¨åŠ¨ç”»æ—¶é—´
                const animRotation = this.animationStates.running.matrix ? 
                    this.animationStates.matrixTime : rotation;
                
                // åˆ›å»ºå˜æ¢çŸ©é˜µ
                const cos = Math.cos(animRotation);
                const sin = Math.sin(animRotation);
                
                const matrix = [
                    scaleX * cos + skewX * scaleY * sin,  -scaleY * sin,
                    scaleX * sin,                          scaleY * cos
                ];
                
                // ç»˜åˆ¶åŸå§‹å½¢çŠ¶ï¼ˆæµ…è‰²ï¼‰
                this.drawShape(ctx, centerX, centerY, 1, 0, 0, 1, 'rgba(255, 255, 255, 0.3)');
                
                // ç»˜åˆ¶å˜æ¢åçš„å½¢çŠ¶
                this.drawShape(ctx, centerX, centerY, matrix[0], matrix[1], matrix[2], matrix[3], '#4ecdc4');
                
                // æ›´æ–°çŸ©é˜µä¿¡æ¯
                const matrixInfo = `[${matrix[0].toFixed(2)} ${matrix[1].toFixed(2)}]\n[${matrix[2].toFixed(2)} ${matrix[3].toFixed(2)}]`;
                document.getElementById('matrixFormula').innerHTML = 
                    `å˜æ¢çŸ©é˜µ:<br>[${matrix[0].toFixed(2)} ${matrix[1].toFixed(2)}]<br>[${matrix[2].toFixed(2)} ${matrix[3].toFixed(2)}]`;
            }

            drawShape(ctx, centerX, centerY, a, b, c, d, color) {
                const points = [
                    [-50, -50], [50, -50], [50, 50], [-50, 50], [-50, -50]
                ];
                
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.beginPath();
                
                points.forEach((point, index) => {
                    const x = point[0] * a + point[1] * b + centerX;
                    const y = point[0] * c + point[1] * d + centerY;
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }

            // è´å¡å°”æ›²çº¿å¯è§†åŒ–
            drawBezierCurve() {
                const ctx = this.canvases.bezier.ctx;
                ctx.clearRect(0, 0, 400, 300);
                
                // è·å–æ§åˆ¶ç‚¹
                const cp1x = parseFloat(document.getElementById('cp1x').value);
                const cp1y = parseFloat(document.getElementById('cp1y').value);
                const cp2x = parseFloat(document.getElementById('cp2x').value);
                const cp2y = parseFloat(document.getElementById('cp2y').value);
                
                const startPoint = { x: 50, y: 250 };
                const endPoint = { x: 350, y: 50 };
                const controlPoint1 = { x: cp1x, y: cp1y };
                const controlPoint2 = { x: cp2x, y: cp2y };
                
                // ç»˜åˆ¶æ§åˆ¶ç‚¹å’Œè¿æ¥çº¿
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.beginPath();
                ctx.moveTo(startPoint.x, startPoint.y);
                ctx.lineTo(controlPoint1.x, controlPoint1.y);
                ctx.moveTo(endPoint.x, endPoint.y);
                ctx.lineTo(controlPoint2.x, controlPoint2.y);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // ç»˜åˆ¶æ§åˆ¶ç‚¹
                this.drawControlPoint(ctx, startPoint.x, startPoint.y, '#ff6b6b', 'P0');
                this.drawControlPoint(ctx, controlPoint1.x, controlPoint1.y, '#4ecdc4', 'P1');
                this.drawControlPoint(ctx, controlPoint2.x, controlPoint2.y, '#4ecdc4', 'P2');
                this.drawControlPoint(ctx, endPoint.x, endPoint.y, '#ff6b6b', 'P3');
                
                // ç»˜åˆ¶è´å¡å°”æ›²çº¿
                ctx.strokeStyle = '#f9ca24';
                ctx.lineWidth = 3;
                ctx.beginPath();
                ctx.moveTo(startPoint.x, startPoint.y);
                
                if (this.currentStates.bezierType === 'cubic') {
                    ctx.bezierCurveTo(controlPoint1.x, controlPoint1.y, controlPoint2.x, controlPoint2.y, endPoint.x, endPoint.y);
                } else {
                    ctx.quadraticCurveTo(controlPoint1.x, controlPoint1.y, endPoint.x, endPoint.y);
                }
                
                ctx.stroke();
                
                // å¦‚æœåŠ¨ç”»è¿è¡Œï¼Œæ˜¾ç¤ºæ„é€ è¿‡ç¨‹
                if (this.animationStates.running.bezier) {
                    this.drawBezierConstruction(ctx, startPoint, controlPoint1, controlPoint2, endPoint, this.animationStates.bezierTime);
                }
            }

            drawControlPoint(ctx, x, y, color, label) {
                ctx.fillStyle = color;
                ctx.beginPath();
                ctx.arc(x, y, 6, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.fillStyle = 'white';
                ctx.font = '12px Arial';
                ctx.fillText(label, x + 10, y - 10);
            }

            drawBezierConstruction(ctx, p0, p1, p2, p3, t) {
                // çº¿æ€§æ’å€¼å‡½æ•°
                const lerp = (a, b, t) => ({ x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t });
                
                // ç¬¬ä¸€çº§æ’å€¼
                const q0 = lerp(p0, p1, t);
                const q1 = lerp(p1, p2, t);
                const q2 = lerp(p2, p3, t);
                
                // ç¬¬äºŒçº§æ’å€¼
                const r0 = lerp(q0, q1, t);
                const r1 = lerp(q1, q2, t);
                
                // æœ€ç»ˆç‚¹
                const s = lerp(r0, r1, t);
                
                // ç»˜åˆ¶æ„é€ çº¿
                ctx.strokeStyle = 'rgba(255, 107, 107, 0.7)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(q0.x, q0.y);
                ctx.lineTo(q1.x, q1.y);
                ctx.lineTo(q2.x, q2.y);
                ctx.stroke();
                
                ctx.strokeStyle = 'rgba(78, 205, 196, 0.7)';
                ctx.beginPath();
                ctx.moveTo(r0.x, r0.y);
                ctx.lineTo(r1.x, r1.y);
                ctx.stroke();
                
                // ç»˜åˆ¶å½“å‰ç‚¹
                ctx.fillStyle = '#f9ca24';
                ctx.beginPath();
                ctx.arc(s.x, s.y, 8, 0, Math.PI * 2);
                ctx.fill();
            }

            // æåæ ‡å›¾å½¢
            drawPolarGraphs() {
                const ctx = this.canvases.polar.ctx;
                ctx.clearRect(0, 0, 400, 300);
                
                const centerX = 200;
                const centerY = 150;
                const a = parseFloat(document.getElementById('polarA').value);
                const b = parseFloat(document.getElementById('polarB').value);
                const scale = parseFloat(document.getElementById('polarScale').value) * 50;
                
                // ç»˜åˆ¶æåæ ‡ç½‘æ ¼
                this.drawPolarGrid(ctx, centerX, centerY);
                
                const type = this.currentStates.polarType;
                
                ctx.strokeStyle = '#4ecdc4';
                ctx.lineWidth = 3;
                ctx.beginPath();
                
                let first = true;
                for (let theta = 0; theta <= Math.PI * 4; theta += 0.02) {
                    let r;
                    
                    switch (type) {
                        case 'rose':
                            r = a * Math.sin(b * theta);
                            break;
                        case 'spiral':
                            r = a * theta / 10;
                            break;
                        case 'cardioid':
                            r = a * (1 + Math.cos(theta));
                            break;
                        case 'lemniscate':
                            const cos2theta = Math.cos(2 * theta);
                            r = cos2theta >= 0 ? a * Math.sqrt(cos2theta) : 0;
                            break;
                    }
                    
                    const x = centerX + r * scale * Math.cos(theta);
                    const y = centerY + r * scale * Math.sin(theta);
                    
                    if (first || (type === 'lemniscate' && r === 0)) {
                        ctx.moveTo(x, y);
                        first = false;
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                // æ›´æ–°å…¬å¼
                const formulas = {
                    rose: `r = ${a} Ã— sin(${b} Ã— Î¸)`,
                    spiral: `r = ${a} Ã— Î¸`,
                    cardioid: `r = ${a} Ã— (1 + cos(Î¸))`,
                    lemniscate: `r = ${a} Ã— âˆš(cos(2Î¸))`
                };
                
                document.getElementById('polarFormula').textContent = formulas[type];
            }

            drawPolarGrid(ctx, centerX, centerY) {
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
                ctx.lineWidth = 1;
                
                // ç»˜åˆ¶åŒå¿ƒåœ†
                for (let r = 20; r <= 120; r += 20) {
                    ctx.beginPath();
                    ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                    ctx.stroke();
                }
                
                // ç»˜åˆ¶å°„çº¿
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 6) {
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + 120 * Math.cos(angle),
                        centerY + 120 * Math.sin(angle)
                    );
                    ctx.stroke();
                }
            }

            // å™ªå£°å‡½æ•°å¯è§†åŒ–
            drawNoise() {
                const ctx = this.canvases.noise.ctx;
                ctx.clearRect(0, 0, 400, 300);
                
                const frequency = parseFloat(document.getElementById('noiseFreq').value);
                const amplitude = parseFloat(document.getElementById('noiseAmp').value);
                const octaves = parseInt(document.getElementById('noiseOctaves').value);
                
                const imageData = ctx.createImageData(400, 300);
                const data = imageData.data;
                
                for (let x = 0; x < 400; x++) {
                    for (let y = 0; y < 300; y++) {
                        let noiseValue = 0;
                        let maxValue = 0;
                        
                        // ç”Ÿæˆåˆ†å½¢å™ªå£°
                        for (let i = 0; i < octaves; i++) {
                            const freq = frequency * Math.pow(2, i);
                            const amp = amplitude / Math.pow(2, i);
                            
                            noiseValue += this.noise(
                                x * freq, 
                                y * freq, 
                                this.animationStates.noiseTime
                            ) * amp;
                            maxValue += amp;
                        }
                        
                        // æ ‡å‡†åŒ–åˆ°0-255
                        const normalizedValue = ((noiseValue / maxValue) + 1) * 127.5;
                        const clampedValue = Math.max(0, Math.min(255, normalizedValue));
                        
                        const index = (y * 400 + x) * 4;
                        
                        // æ ¹æ®å™ªå£°ç±»å‹è®¾ç½®é¢œè‰²
                        if (this.currentStates.noiseType === 'perlin') {
                            data[index] = clampedValue * 0.7;     // R
                            data[index + 1] = clampedValue;       // G
                            data[index + 2] = clampedValue * 0.8; // B
                        } else {
                            data[index] = clampedValue;           // R
                            data[index + 1] = clampedValue * 0.8; // G
                            data[index + 2] = clampedValue * 0.6; // B
                        }
                        data[index + 3] = 255; // A
                    }
                }
                
                ctx.putImageData(imageData, 0, 0);
            }

            // ç®€å•çš„å™ªå£°å‡½æ•°å®ç°
            noise(x, y, z = 0) {
                // ä¼ªéšæœºå™ªå£°å‡½æ•°
                const n = Math.sin(x * 12.9898 + y * 78.233 + z * 37.719) * 43758.5453;
                return (n - Math.floor(n)) * 2 - 1;
            }
        }

        // å…¨å±€å‡½æ•° - å‘é‡æ“ä½œ
        function showVectorOperation(operation) {
            mathViz.currentStates.vectorOperation = operation;
            document.getElementById('vectorOperation').textContent = {
                add: 'å‘é‡ç›¸åŠ ',
                subtract: 'å‘é‡ç›¸å‡',
                dot: 'ç‚¹ç§¯è¿ç®—',
                cross: 'å‰ç§¯è¿ç®—'
            }[operation];
            mathViz.drawVectors();
        }

        // ä¸‰è§’å‡½æ•°é€‰æ‹©
        function selectTrigFunction(func) {
            mathViz.currentStates.trigFunction = func;
            document.querySelectorAll('.demo-card:nth-child(2) .btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // çŸ©é˜µå˜æ¢æ§åˆ¶
        function resetMatrix() {
            document.getElementById('rotation').value = 0;
            document.getElementById('scaleX').value = 1;
            document.getElementById('scaleY').value = 1;
            document.getElementById('skewX').value = 0;
            
            // æ›´æ–°æ˜¾ç¤º
            document.getElementById('rotationValue').textContent = '0Â°';
            document.getElementById('scaleXValue').textContent = '1.0';
            document.getElementById('scaleYValue').textContent = '1.0';
            document.getElementById('skewXValue').textContent = '0.0';
            
            mathViz.drawMatrixTransformation();
        }

        function animateMatrix() {
            mathViz.animationStates.running.matrix = !mathViz.animationStates.running.matrix;
            event.target.textContent = mathViz.animationStates.running.matrix ? 'åœæ­¢åŠ¨ç”»' : 'åŠ¨ç”»æ¼”ç¤º';
        }

        function showMatrixInfo() {
            alert('çŸ©é˜µå˜æ¢å¯ä»¥ç»„åˆæ—‹è½¬ã€ç¼©æ”¾ã€å€¾æ–œç­‰æ“ä½œã€‚æ¯ä¸ªå˜æ¢éƒ½å¯ä»¥ç”¨2x2çŸ©é˜µè¡¨ç¤ºï¼Œå¤šä¸ªå˜æ¢å¯ä»¥é€šè¿‡çŸ©é˜µä¹˜æ³•ç»„åˆã€‚');
        }

        // è´å¡å°”æ›²çº¿æ§åˆ¶
        function setBezierType(type) {
            mathViz.currentStates.bezierType = type;
            document.querySelectorAll('.demo-card:nth-child(4) .btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            mathViz.drawBezierCurve();
        }

        function animateBezier() {
            mathViz.animationStates.running.bezier = !mathViz.animationStates.running.bezier;
            event.target.textContent = mathViz.animationStates.running.bezier ? 'åœæ­¢åŠ¨ç”»' : 'åŠ¨ç”»æ¼”ç¤º';
        }

        function showBezierConstruction() {
            alert('è´å¡å°”æ›²çº¿é€šè¿‡é€’å½’çº¿æ€§æ’å€¼æ„é€ ã€‚è§‚å¯ŸåŠ¨ç”»å¯ä»¥çœ‹åˆ°æ§åˆ¶ç‚¹å¦‚ä½•å½±å“æ›²çº¿å½¢çŠ¶ã€‚');
        }

        // æåæ ‡å›¾å½¢æ§åˆ¶
        function setPolarType(type) {
            mathViz.currentStates.polarType = type;
            document.querySelectorAll('.demo-card:nth-child(5) .btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            mathViz.drawPolarGraphs();
        }

        // å™ªå£°å‡½æ•°æ§åˆ¶
        function setNoiseType(type) {
            mathViz.currentStates.noiseType = type;
            document.querySelectorAll('.demo-card:nth-child(6) .btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
            mathViz.drawNoise();
        }

        function animateNoise() {
            mathViz.animationStates.running.noise = !mathViz.animationStates.running.noise;
            event.target.textContent = mathViz.animationStates.running.noise ? 'åœæ­¢åŠ¨ç”»' : 'åŠ¨ç”»';
        }

        // åˆå§‹åŒ–
        let mathViz;
        document.addEventListener('DOMContentLoaded', () => {
            mathViz = new MathVisualization();
            
            setTimeout(() => {
                console.log(`
ğŸ“ å›¾å½¢æ•°å­¦å¯è§†åŒ–ä½¿ç”¨æŒ‡å—ï¼š

ğŸ”§ åŠŸèƒ½æ¨¡å—ï¼š
â”œâ”€â”€ å‘é‡æ“ä½œ: å¯è§†åŒ–å‘é‡åŠ æ³•ã€å‡æ³•ã€ç‚¹ç§¯ã€å‰ç§¯
â”œâ”€â”€ ä¸‰è§’å‡½æ•°: è§‚å¯Ÿæ­£å¼¦ã€ä½™å¼¦ã€æ­£åˆ‡æ³¢å½¢åŠå‚æ•°å½±å“
â”œâ”€â”€ çŸ©é˜µå˜æ¢: æ—‹è½¬ã€ç¼©æ”¾ã€å€¾æ–œå˜æ¢çš„å®æ—¶é¢„è§ˆ
â”œâ”€â”€ è´å¡å°”æ›²çº¿: äº¤äº’å¼æ§åˆ¶ç‚¹è°ƒèŠ‚å’Œæ„é€ è¿‡ç¨‹æ¼”ç¤º
â”œâ”€â”€ æåæ ‡å›¾å½¢: ç«ç‘°çº¿ã€èºæ—‹çº¿ç­‰æ•°å­¦å›¾å½¢
â””â”€â”€ å™ªå£°å‡½æ•°: Perlinå™ªå£°çš„å¯è§†åŒ–å’Œåº”ç”¨

ğŸ® æ“ä½œæç¤ºï¼š
- æ‹–åŠ¨æ»‘å—è°ƒèŠ‚å‚æ•°ï¼Œå®æ—¶è§‚å¯Ÿå˜åŒ–
- ç‚¹å‡»æŒ‰é’®åˆ‡æ¢ä¸åŒæ¨¡å¼å’ŒåŠŸèƒ½
- è§‚å¯Ÿæ•°å­¦å…¬å¼ä¸å›¾å½¢çš„å¯¹åº”å…³ç³»
- å°è¯•ç†è§£å„ç§å‚æ•°å¯¹å›¾å½¢çš„å½±å“

æ¢ç´¢æ•°å­¦ä¸å›¾å½¢çš„ç¾å¦™å…³ç³»! ğŸŒŸ
                `);
            }, 1000);
        });
    </script>
</body>
</html> 